重写要求保持equals特性：自反性；对称性；传递性；一致性；对于任意非空引用x，x.equals（null）返回false；
这里其他四条除了对称性比较容易实现
对称性要求形式上：x.equals(y)=y.equals(x)
这就分为了两种情：
一是比较目的是两对象从共有的域上判定是否相等，则两者或者存在继承关系，或者继承相同的父类
此时父类equals方法实现中的判断条件应为instanceofFatherclass，并且子类继承该方法且不重写覆盖（instanceof的                             来源是为了类型转换）
 比如上面的y是x的子类，x的equals方法参数为子类时返回true，则y的equals方法参数为父类必须返回true，这就要求y的equals方法无论是instanceofFatherclass这个判定条件，还是比较的具体的域都不能改变，也就是完全继承自父类的方法，一旦改变（重写），对称性就无法成立，继承该方法的两个不同子类也可以比较，这就是从共有域判定相等性的目的，如果绝对的从公有域上判断，甚至应该写为final的 
                              
这是为了保证这种置换性（多态的另一种表述）、灵活性所要求的规则，一旦以这种方式，子类的equals方法就不能重写了，有一些造的类就是有这个问题，让使用者没有办法在重写的同时保证对称性，所以要想清楚目的和不得不做的要求  

另一种情况是绝对的同类比较，则用getclass判定条件进行筛选，它允许子类继承与重写（包括改为instanceof判定和附加新的域的比较），getclass可以与instanceof相同的在类型转换前完成类型判定的目的，但它是绝对同类的比较，父类与子类和不同子类之间都不能比较，好的方法是用getclass作为判定条件，这样即允许继承有允许重写，都不会影响对称性


instanceof检验是在重写过程中，子类要在方法中访问子类的数据域需要强制转换所带来的需求，签名中参数是父类实际参数类型为子类，需要转换
通过getclass检验可以达到同样的作用，因为实例方法的实例是具体定义的子类，如果类型相同则一定为子类

但不同的是：
在重写equals方法时，如果考虑到此类的子类还会重写equals方法，那么如果此处的equals方法用instanceof检测，对称性就无法实现，比如b是a的子类，a.equals(b)会返回true，而b.equals(a)返回false，第二个equals是重写的包含子类的特殊域，否则就不是重写了，如果不重写而是继承父类的equals，那么instanceof检验就无所谓了，如果重写用getclass检验就不会有这个问题了

一些人认为应该保持置换原则（置换原则就是多态的另一种表述），父类型声明变量或参数位置放入子类实际类型，置换原则有些意味预期结果应该相同的，但是用getclass检测，当传入子类参数时，equals返回false。但是这样子类就没办法重写的同时保持对称性。
其实这也是和目的相关的，如果使用父类公共域决定是否相等，就应该用instanceof检测，同时不应该重写，如果想要保留可以重写的机会，就应该用getclass检测，但是父类与子类比较无法相等，不能保证置换原则
                              
                              