对于继承类与多个接口后，同名方法的调用冲突：
（1）对于静态方法采用类名调用避免冲突；
（2）从父类和接口中继承了同名的方法和默认方法，父类优先；（这保证了为接口增加默认方法不会影响之前代码的任何工作）
（3）从两个接口中继承了同名的两个默认方法，要求子类必须根据其一对默认方法进行重写，即在子类中提供此名方法，否则会报错；
（4）从一个接口中继承了默认方法，另一个接口中有同名的抽象方法，这仍然会带来冲突，java的设计者在至少有一个接口提供了实现时就会让编译器报错，因为任何时候想要实现这个抽象方法都会带来同名冲突，也必须在此类中提供此名方法来避免二义（这是语法意义层面上调用时不会引起冲突，实际目的意义上一定是其中一个方法的丢失，只能选其一，或者说是同时满足）；
如果父类中的方法和父接口中的抽象方法重名，继承父类与接口的子类中如果没有重写抽象方法，默认为父类的同名方法实现了接口方法，此子类为非抽象类。这可以通过将父类中该方法注释掉发现报错未实现接口方法来反映，而且重写同名方法显示重写的是父类方法。
（5）两个接口中提供两个同名抽象方法都没有默认实现，继承两接口编译器不会报错，继承接口的类中方法的重写是相当于对两个抽象方法的同时重写
     如果两抽象方法同名但返回值不同则无法同时继承，子类重写方法总会无法满足其中一个返回值，编译就会报错，相当于一个类内不能同时
定义两个名字相同返回值不同的方法，会引起歧义。
     如果两抽象方法抛出异常类型不同，则子类重写方法可以不抛出异常或者抛出二者异常的交集达到同时满足重写的语法要求（子类对于抛出
异常的方法的重写新抛出的异常不能更加宽泛也就是可以是其子异常类型或者是不抛出异常）
（6）类中继承方法与子类中抽象方法同名这与（4）相同
  总之，在调用方法不会引起冲突就好，同时符合语法规则，实现接口必须实现同名方法